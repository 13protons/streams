{"version":3,"sources":["webpack:///dist/streams.js","webpack:///webpack/bootstrap d5707e1fa0005a275924","webpack:///./index.js","webpack:///./src/module.js","webpack:///./src/writeable_stream.js","webpack:///./node_modules/loglevel/lib/loglevel.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","window","Stream","writeable","WriteableStream","options","writeCallback","setLogLevel","level","log","setLevel","flush","drain","next","writeResult","msg","Buffer","setTimeout","announce","state","hasCapacity","isFlushing","result","done","info","then","catch","err","length","let","callback","corked","cork","uncork","getBuffer","end","data","cb","write","register","finished","eventName","events","once","registerOnce","obj","Error","push","highWaterMark","WriteableState","defaults","objectMode","params","assign","isCorked","hasEnded","val","console","error","on","_loglevel","_writableState","getLogger","setDefaultLevel","levels","SILENT","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","definition","undefined","this","realMethod","methodName","undefinedType","bindMethod","noop","method","bind","Function","e","apply","arguments","enableLoggingWhenConsoleArrives","loggerName","replaceLoggingMethods","this$1","logMethods","methodFactory","defaultMethodFactory","Logger","defaultLevel","factory","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","storageKey","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","location","indexOf","exec","slice","self","currentLevel","TRACE","DEBUG","INFO","WARN","ERROR","getLevel","persist","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","TypeError","logger","_log","noConflict"],"mappings":"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","file":"./dist/streams.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// (function(root, factory) {\n//   if (typeof module === 'object' && module.exports) {\n//     // Node. Does not work with strict CommonJS, but\n//     // only CommonJS-like environments that support module.exports,\n//     // like Node.\n//     module.exports = factory();\n//   } else {\n//     // Browser globals (root is window)\n//     console.log('add to browser');\n//     console.log('root');\n//     root.Stream = factory();\n//   }\n// }(window, function() {\n//   return require('./src/module.js');\n// }));\n\nwindow.Stream = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  writeable: __webpack_require__(2)\n};\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// reimplement some features of node steams for the browser\nvar log = __webpack_require__(3).getLogger('writeable');\nlog.setDefaultLevel(log.levels.SILENT);\n\nmodule.exports = function(options, cb) {\n  return new WriteableStream(options, cb);\n}\n\nfunction WriteableStream(options, writeCallback) {\n  var callback = writeCallback;\n  if (typeof(options) === 'function') {\n    callback = options;\n  }\n\n  if (typeof(callback) !== 'function') {\n    console.error('must supply write callback');\n    return;\n  }\n  // The amount of data potentially buffered depends on the highWaterMark option passed into the streams constructor. For normal streams, the highWaterMark option specifies a total number of bytes.For streams operating in object mode, the highWaterMark specifies a total number of objects.\n  var Buffer = [];\n  var events = {};\n  var state = new WriteableState(options);\n\n  return {\n    write: write,\n    push: write,\n    cork: cork,\n    uncork: uncork,\n    end: end,\n    on: register,\n    once: registerOnce,\n    _loglevel: setLogLevel,\n    _writableState: state\n  }\n\n  function setLogLevel(level) {\n    log.setLevel(level, false);\n  }\n\n  function flush() {\n    if (Buffer.length === 0 || state.isFlushing) {\n      return;\n    }\n    log.info('WRITEABLE - flushing buffer');\n\n    state.isFlushing = true;\n    var writeResult;\n\n    try {\n      writeResult = callback(Buffer);\n    } catch(err) {\n      announce('error', err);\n    }\n\n    if (!state.hasCapacity) {\n      log.info('WRITEABLE - buffer was previously over capacity');\n      drain();\n    } else if (state.corked) {\n      log.info('WRITEABLE - buffer was corked');\n      state.corked = false;\n      drain();\n    } else {\n      next(writeResult, function(){\n        Buffer = [];\n        state.isFlushing = false;\n      })\n    }\n\n    return writeResult;\n\n    function drain() {\n      next(writeResult, function (msg) {\n        Buffer = [];\n        setTimeout(function(){\n          announce('drain', msg);\n        });\n        state.hasCapacity = true;\n        state.isFlushing = false;\n      });\n    }\n    function next(result, done) {\n      if (result && typeof(result.then) === 'function') {\n        log.info('WRITEABLE - init callback was a promise');\n        // treat as promise\n        result.then(done).catch(function(err){\n          announce('error', err);\n        })\n      } else {\n        done(Buffer);\n      }\n    }\n  }\n\n  function cork() {\n    log.info('WRITEABLE - corking stream');\n    state.corked = true;\n  }\n\n  function uncork() {\n    log.info('WRITEABLE - uncorking stream');\n    if (state.corked && state.getBuffer().length > 0) {\n      flush();\n    }\n    state.corked = false;\n  }\n\n  function end(data, cb) {\n    log.info('WRITEABLE - ending stream. No more writes possible after this one.');\n    if (typeof(data) === 'function') {\n      cb = data;\n    } else if (data) {\n      write(data);\n    }\n    if (typeof(cb) === 'function') {\n      register('finish', cb);\n    }\n    state.finished = true;\n    setTimeout(function(){\n      flush();\n      announce('finish')\n    })\n  }\n\n  function register(eventName, cb) {\n    log.info('WRITEABLE - registering callback for event', eventName);\n    events[eventName] = {\n      once: false,\n      callback: cb\n    }\n  }\n\n  function registerOnce(eventName, cb) {\n    log.info('WRITEABLE - registering one time callback for event', eventName);\n    events[eventName] = {\n      once: true,\n      callback: cb\n    }\n  }\n\n  function write(obj) {\n    log.info('WRITEABLE - write object to stream - \"', obj, '\"');\n    if (state.finished) {\n      throw new Error('Stream has ended - writes are no longer allowed!');\n      return;\n    }\n    // Data is buffered in Readable streams when the implementation calls stream.push(chunk).If the consumer of the Stream does not call stream.read(), the data will sit in the internal queue until it is consumed.\n\n    // Data is buffered in Writable streams when the writable.write(chunk) method is called repeatedly. While the total size of the internal write buffer is below the threshold set by highWaterMark, calls to writable.write() will return true.Once the size of the internal buffer reaches or exceeds the highWaterMark, false will be returned.\n    Buffer.push(obj);\n\n    if (!state.corked) {\n      setTimeout(flush)\n    }\n\n    if (Buffer.length >= state.highWaterMark) {\n      state.hasCapacity = false;\n    }\n\n    return state.hasCapacity;\n  }\n\n  function WriteableState(options) {\n    log.info('WRITEABLE - initializing stream');\n    options = typeof(options) === 'function' ? {} : options;\n    var defaults = {\n      objectMode: true, // always true. Changes will be ignored\n      highWaterMark: 100 // objects to buffer\n    }\n    var params = Object.assign(defaults, options);\n\n    var isCorked = false;\n    var hasCapacity = true;\n    var hasEnded = false;\n    return {\n      get finished() {\n        return hasEnded;\n      },\n      set finished(val) {\n        // no turning back!\n        hasEnded = true\n      },\n      get corked() {\n        return isCorked;\n      },\n      set corked(val) {\n        if (val && isCorked === false) {\n          isCorked = true;\n        }\n        if (!val) {\n          isCorked = false;\n        }\n      },\n      get highWaterMark() {\n        return params.highWaterMark;\n      },\n      get hasCapacity() {\n        return hasCapacity;\n      },\n      set hasCapacity(val) {\n        if (val && hasCapacity === false) {\n          hasCapacity = true;\n        }\n        if (!val) {\n          hasCapacity = false;\n        }\n      },\n      getBuffer: function () {\n        return Buffer;\n      }\n    }\n  }\n\n  function announce(name, data) {\n    log.info('WRITEABLE - event triggered', name, data);\n    if (events[name] && typeof(events[name].callback) === 'function') {\n      if (name === 'error') {\n        console.error(data);\n      }\n      events[name].callback(data);\n      if (events[name].once) {\n        delete events[name];\n      }\n    }\n  }\n}\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    function realMethod(methodName) {\n        if (typeof console === undefinedType) {\n            return false; // We can't build a real method without a console to log to\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // these private functions always need `this` to be set properly\n\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    function replaceLoggingMethods(level, loggerName) {\n        var this$1 = this;\n\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this$1[methodName] = (i < level) ?\n                noop :\n                this$1.methodFactory(methodName, level, loggerName);\n        }\n    }\n\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public API\n       *\n       */\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Package-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    return defaultLogger;\n}));\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/streams.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d5707e1fa0005a275924","// (function(root, factory) {\n//   if (typeof module === 'object' && module.exports) {\n//     // Node. Does not work with strict CommonJS, but\n//     // only CommonJS-like environments that support module.exports,\n//     // like Node.\n//     module.exports = factory();\n//   } else {\n//     // Browser globals (root is window)\n//     console.log('add to browser');\n//     console.log('root');\n//     root.Stream = factory();\n//   }\n// }(window, function() {\n//   return require('./src/module.js');\n// }));\n\nwindow.Stream = require('./src/module.js');\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","module.exports = {\n  writeable: require('./writeable_stream')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/module.js","// reimplement some features of node steams for the browser\nlet log = require('loglevel').getLogger('writeable');\nlog.setDefaultLevel(log.levels.SILENT);\n\nmodule.exports = function(options, cb) {\n  return new WriteableStream(options, cb);\n}\n\nfunction WriteableStream(options, writeCallback) {\n  let callback = writeCallback;\n  if (typeof(options) === 'function') {\n    callback = options;\n  }\n\n  if (typeof(callback) !== 'function') {\n    console.error('must supply write callback');\n    return;\n  }\n  // The amount of data potentially buffered depends on the highWaterMark option passed into the streams constructor. For normal streams, the highWaterMark option specifies a total number of bytes.For streams operating in object mode, the highWaterMark specifies a total number of objects.\n  let Buffer = [];\n  let events = {};\n  let state = new WriteableState(options);\n\n  return {\n    write: write,\n    push: write,\n    cork: cork,\n    uncork: uncork,\n    end: end,\n    on: register,\n    once: registerOnce,\n    _loglevel: setLogLevel,\n    _writableState: state\n  }\n\n  function setLogLevel(level) {\n    log.setLevel(level, false);\n  }\n\n  function flush() {\n    if (Buffer.length === 0 || state.isFlushing) {\n      return;\n    }\n    log.info('WRITEABLE - flushing buffer');\n\n    state.isFlushing = true;\n    let writeResult;\n\n    try {\n      writeResult = callback(Buffer);\n    } catch(err) {\n      announce('error', err);\n    }\n\n    if (!state.hasCapacity) {\n      log.info('WRITEABLE - buffer was previously over capacity');\n      drain();\n    } else if (state.corked) {\n      log.info('WRITEABLE - buffer was corked');\n      state.corked = false;\n      drain();\n    } else {\n      next(writeResult, function(){\n        Buffer = [];\n        state.isFlushing = false;\n      })\n    }\n\n    return writeResult;\n\n    function drain() {\n      next(writeResult, function (msg) {\n        Buffer = [];\n        setTimeout(function(){\n          announce('drain', msg);\n        });\n        state.hasCapacity = true;\n        state.isFlushing = false;\n      });\n    }\n    function next(result, done) {\n      if (result && typeof(result.then) === 'function') {\n        log.info('WRITEABLE - init callback was a promise');\n        // treat as promise\n        result.then(done).catch(function(err){\n          announce('error', err);\n        })\n      } else {\n        done(Buffer);\n      }\n    }\n  }\n\n  function cork() {\n    log.info('WRITEABLE - corking stream');\n    state.corked = true;\n  }\n\n  function uncork() {\n    log.info('WRITEABLE - uncorking stream');\n    if (state.corked && state.getBuffer().length > 0) {\n      flush();\n    }\n    state.corked = false;\n  }\n\n  function end(data, cb) {\n    log.info('WRITEABLE - ending stream. No more writes possible after this one.');\n    if (typeof(data) === 'function') {\n      cb = data;\n    } else if (data) {\n      write(data);\n    }\n    if (typeof(cb) === 'function') {\n      register('finish', cb);\n    }\n    state.finished = true;\n    setTimeout(function(){\n      flush();\n      announce('finish')\n    })\n  }\n\n  function register(eventName, cb) {\n    log.info('WRITEABLE - registering callback for event', eventName);\n    events[eventName] = {\n      once: false,\n      callback: cb\n    }\n  }\n\n  function registerOnce(eventName, cb) {\n    log.info('WRITEABLE - registering one time callback for event', eventName);\n    events[eventName] = {\n      once: true,\n      callback: cb\n    }\n  }\n\n  function write(obj) {\n    log.info('WRITEABLE - write object to stream - \"', obj, '\"');\n    if (state.finished) {\n      throw new Error('Stream has ended - writes are no longer allowed!');\n      return;\n    }\n    // Data is buffered in Readable streams when the implementation calls stream.push(chunk).If the consumer of the Stream does not call stream.read(), the data will sit in the internal queue until it is consumed.\n\n    // Data is buffered in Writable streams when the writable.write(chunk) method is called repeatedly. While the total size of the internal write buffer is below the threshold set by highWaterMark, calls to writable.write() will return true.Once the size of the internal buffer reaches or exceeds the highWaterMark, false will be returned.\n    Buffer.push(obj);\n\n    if (!state.corked) {\n      setTimeout(flush)\n    }\n\n    if (Buffer.length >= state.highWaterMark) {\n      state.hasCapacity = false;\n    }\n\n    return state.hasCapacity;\n  }\n\n  function WriteableState(options) {\n    log.info('WRITEABLE - initializing stream');\n    options = typeof(options) === 'function' ? {} : options;\n    let defaults = {\n      objectMode: true, // always true. Changes will be ignored\n      highWaterMark: 100 // objects to buffer\n    }\n    let params = Object.assign(defaults, options);\n\n    let isCorked = false;\n    let hasCapacity = true;\n    let hasEnded = false;\n    return {\n      get finished() {\n        return hasEnded;\n      },\n      set finished(val) {\n        // no turning back!\n        hasEnded = true\n      },\n      get corked() {\n        return isCorked;\n      },\n      set corked(val) {\n        if (val && isCorked === false) {\n          isCorked = true;\n        }\n        if (!val) {\n          isCorked = false;\n        }\n      },\n      get highWaterMark() {\n        return params.highWaterMark;\n      },\n      get hasCapacity() {\n        return hasCapacity;\n      },\n      set hasCapacity(val) {\n        if (val && hasCapacity === false) {\n          hasCapacity = true;\n        }\n        if (!val) {\n          hasCapacity = false;\n        }\n      },\n      getBuffer: () => {\n        return Buffer;\n      }\n    }\n  }\n\n  function announce(name, data) {\n    log.info('WRITEABLE - event triggered', name, data);\n    if (events[name] && typeof(events[name].callback) === 'function') {\n      if (name === 'error') {\n        console.error(data);\n      }\n      events[name].callback(data);\n      if (events[name].once) {\n        delete events[name];\n      }\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/writeable_stream.js","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    function realMethod(methodName) {\n        if (typeof console === undefinedType) {\n            return false; // We can't build a real method without a console to log to\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // these private functions always need `this` to be set properly\n\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n    }\n\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public API\n       *\n       */\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Package-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    return defaultLogger;\n}));\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/loglevel/lib/loglevel.js"],"sourceRoot":""}